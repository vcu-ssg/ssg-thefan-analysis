---
title: Parcels and Addresses Join
---

```{python}
import os
import re
import sys
import sqlite3
import requests
import numpy as np
import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt

from matplotlib.patches import Patch
from matplotlib.lines import Line2D
from math import floor

from loguru import logger
# Configure loguru to only log to stderr (console)
logger.remove()  # remove default handler
logger.add(sys.__stderr__, level="INFO", format="{level: <8} | {name}:{function}:{line} - {message}" )  # use the original stderr, not Jupyter’s proxy

## Set up itables
import itables
from itables import show
# 🔧 Sensible global defaults for itables
itables.options.maxBytes = 0                        # show full content in each cell
itables.options.classes = ["display", "compact"]    # compact, clean look
itables.options.lengthMenu = [10, 25, 50, 100]      # page length menu
itables.options.pageLength = 25
itables.options.buttons = ["copy", "csv", "print"]
itables.options.scrollX = True                      # allow horizontal scroll if needed
itables.options.scrollY = True                      # allow horizontal scroll if needed
itables.options.ordering = True

## Set up duckdb

import duckdb
con = duckdb.connect()
x = con.execute("INSTALL spatial; LOAD spatial;")

sys.path.append("..")
from fandu.geo_utils import get_newest_file

pd.set_option("display.max_rows", None)

precious_folder = "../precious/"

features = ["Addresses"]

selector = "Civic_Associations"
selector_key = "Fan District Association"

fda_contacts_filename = get_newest_file( precious_folder,'FDA_contacts',ext='.csv')

```
```{python}

def show_result_set( query, **kwargs ):
    print('::: {.column-screen-inset style="font-size:0.7em"}')
    df = con.execute( query ).fetch_df()
    show(df,**kwargs)
    print(':::')

```



# Create merge file

```{python}
x = con.execute("""
CREATE OR REPLACE TABLE addresses AS SELECT * FROM 'Addresses_in_fan.parquet';
CREATE OR REPLACE TABLE parcels AS SELECT * FROM 'Parcels_in_fan.parquet';
""");
```

```{python}
#| output: asis

x = con.execute("""
CREATE OR REPLACE TABLE parcel_address_join AS
SELECT 
    p.ParcelID,
    p.PIN,
    p.AsrLocationBldgNo,
    p.OwnerName,
    p.MailAddress,
    a.AddressId,
    a.BuildingNumber,
    a.StreetName,
    a.Mailable AS AddressMailable,
    p.LandUse,
    p.PropertyClass,
    p.geometry AS parcel_geom,
    a.geometry AS addr_geom
FROM parcels p
LEFT JOIN addresses a
  ON ST_Within(a.geometry, p.geometry);
""")
```

```{python}
#| output: asis
show_result_set("""
WITH classified AS (
  SELECT 
    ParcelID,
    COUNT(DISTINCT AddressId) AS address_count,
    COUNT_IF(AddressMailable = 'Yes') AS mailable_count
  FROM parcel_address_join
  GROUP BY ParcelID
)
SELECT
  CASE
    WHEN address_count = 0 THEN 'No match'
    WHEN address_count = 1 AND mailable_count = 1 THEN 'Single address (mailable)'
    WHEN address_count = 1 AND mailable_count = 0 THEN 'Single address (not mailable)'
    WHEN address_count > 1 AND mailable_count = 1 THEN 'Multiple addresses (1 mailable)'
    WHEN address_count > 1 AND mailable_count > 1 THEN 'Multiple addresses (many mailable)'
    WHEN address_count > 1 AND mailable_count = 0 THEN 'Multiple addresses (none mailable)'
    ELSE 'Unclassified'
  END AS match_category,
  COUNT(*) AS parcel_count
FROM classified
GROUP BY match_category
ORDER BY parcel_count DESC;

""",pageLength=10)
```


```{python}
#| output: asis
show_result_set("""
WITH address_classified AS (
  SELECT 
    AddressId,
    COUNT(DISTINCT ParcelID) AS parcel_count
  FROM parcel_address_join
  GROUP BY AddressId
)
SELECT
  CASE
    WHEN parcel_count = 0 THEN 'No parcel match'
    WHEN parcel_count = 1 THEN 'Single parcel'
    WHEN parcel_count > 1 THEN 'Multiple parcels'
  END AS parcel_category,
  COUNT(*) AS address_count
FROM address_classified
GROUP BY parcel_category
ORDER BY address_count DESC;
""",pageLength=10)
```


```{python}
#| output: asis
show_result_set("""
select LandUse, PropertyClass
from parcel_address_join
group by LandUse, PropertyClass
order by LandUse,PropertyClass
""",pageLength=100)
```



```{python}
#| output: asis
show_result_set("""
WITH classified AS (
  SELECT 
    ParcelID,
    LandUse,
    PropertyClass,
    COUNT(DISTINCT AddressId) AS address_count,
    COUNT_IF(AddressMailable = 'Yes') AS mailable_count
  FROM parcel_address_join
  GROUP BY ParcelID, LandUse, PropertyClass
)
SELECT
  LandUse,
  PropertyClass,
  CASE
    WHEN address_count = 0 THEN 'No match'
    WHEN address_count = 1 AND mailable_count = 1 THEN 'Single address (mailable)'
    WHEN address_count = 1 AND mailable_count = 0 THEN 'Single address (not mailable)'
    WHEN address_count > 1 AND mailable_count = 1 THEN 'Multiple addresses (1 mailable)'
    WHEN address_count > 1 AND mailable_count > 1 THEN 'Multiple addresses (many mailable)'
    WHEN address_count > 1 AND mailable_count = 0 THEN 'Multiple addresses (none mailable)'
    ELSE 'Unclassified'
  END AS match_category,
  COUNT(*) AS parcel_count
FROM classified
GROUP BY LandUse, PropertyClass, match_category
ORDER BY LandUse, parcel_count DESC;
""",pageLength=150)
```


```{python}
#| output: asis
show_result_set("""
WITH summary AS (
  SELECT
    ParcelID,
    LandUse,
    PropertyClass,
    COUNT(DISTINCT AddressId) AS address_count,
    COUNT_IF(AddressMailable = 'Yes') AS mailable_count,
    CASE
      WHEN COUNT(DISTINCT AddressId) = 0 THEN 'No match'
      WHEN COUNT(DISTINCT AddressId) = 1 AND COUNT_IF(AddressMailable = 'Yes') = 1
        THEN 'Single address (mailable)'
      WHEN COUNT(DISTINCT AddressId) = 1 AND COUNT_IF(AddressMailable = 'Yes') = 0
        THEN 'Single address (not mailable)'
      WHEN COUNT(DISTINCT AddressId) > 1 AND COUNT_IF(AddressMailable = 'Yes') = 1
        THEN 'Multiple addresses (1 mailable)'
      WHEN COUNT(DISTINCT AddressId) > 1 AND COUNT_IF(AddressMailable = 'Yes') > 1
        THEN 'Multiple addresses (many mailable)'
      WHEN COUNT(DISTINCT AddressId) > 1 AND COUNT_IF(AddressMailable = 'Yes') = 0
        THEN 'Multiple addresses (none mailable)'
      ELSE 'Unclassified'
    END AS match_category
  FROM parcel_address_join
  GROUP BY ParcelID, LandUse, PropertyClass
),
flagged AS (
  SELECT
    ParcelID,
    LandUse,
    match_category,
    CASE
      WHEN LandUse LIKE 'Single Family%' AND match_category = 'Single address (mailable)'
        THEN 'Expected'
      WHEN LandUse LIKE 'Single Family%' AND match_category <> 'Single address (mailable)'
        THEN 'Unexpected'
      WHEN LandUse IN ('Duplex (2 Family)', 'Multi-Family', 'Mixed-Use')
           AND match_category LIKE 'Multiple addresses%'
        THEN 'Expected'
      WHEN LandUse IN ('Duplex (2 Family)', 'Multi-Family', 'Mixed-Use')
           AND match_category NOT LIKE 'Multiple addresses%'
        THEN 'Unexpected'
      WHEN LandUse IN ('Commercial','Office','Institutional')
           AND match_category IN ('Multiple addresses (many mailable)','Single address (mailable)')
        THEN 'Expected'
      WHEN LandUse IN ('Commercial','Office','Institutional')
           AND match_category NOT IN ('Multiple addresses (many mailable)','Single address (mailable)')
        THEN 'Unexpected'
      WHEN LandUse IN ('Vacant','Public-Open Space')
           AND match_category LIKE '%not mailable%'
        THEN 'Expected'
      WHEN LandUse IN ('Vacant','Public-Open Space')
           AND match_category NOT LIKE '%not mailable%'
        THEN 'Unexpected'
      ELSE 'Review'
    END AS expectation_flag
  FROM summary
)
SELECT
  LandUse,
  COUNT(*) FILTER (WHERE expectation_flag = 'Expected')   AS expected_count,
  COUNT(*) FILTER (WHERE expectation_flag = 'Unexpected') AS unexpected_count,
  COUNT(*) FILTER (WHERE expectation_flag = 'Review')     AS review_count,
  COUNT(*)                                               AS total_count
FROM flagged
GROUP BY LandUse
ORDER BY total_count DESC;
""",pageLength=100);
```


```{python}
#| output: asis
show_result_set("""
WITH summary AS (
  SELECT
    ParcelID,
    LandUse,
    PropertyClass,
    COUNT(DISTINCT AddressId) AS address_count,
    COUNT_IF(AddressMailable = 'Yes') AS mailable_count,
    CASE
      WHEN COUNT(DISTINCT AddressId) = 0 THEN 'No match'
      WHEN COUNT(DISTINCT AddressId) = 1 AND COUNT_IF(AddressMailable = 'Yes') = 1
        THEN 'Single address (mailable)'
      WHEN COUNT(DISTINCT AddressId) = 1 AND COUNT_IF(AddressMailable = 'Yes') = 0
        THEN 'Single address (not mailable)'
      WHEN COUNT(DISTINCT AddressId) > 1 AND COUNT_IF(AddressMailable = 'Yes') = 1
        THEN 'Multiple addresses (1 mailable)'
      WHEN COUNT(DISTINCT AddressId) > 1 AND COUNT_IF(AddressMailable = 'Yes') > 1
        THEN 'Multiple addresses (many mailable)'
      WHEN COUNT(DISTINCT AddressId) > 1 AND COUNT_IF(AddressMailable = 'Yes') = 0
        THEN 'Multiple addresses (none mailable)'
      ELSE 'Unclassified'
    END AS match_category
  FROM parcel_address_join
  GROUP BY ParcelID, LandUse, PropertyClass
),
flagged AS (
  SELECT
    ParcelID,
    LandUse,
    PropertyClass,
    match_category,
    CASE
      WHEN LandUse LIKE 'Single Family%' 
           AND match_category = 'Single address (mailable)'
        THEN 'Expected'
      WHEN LandUse LIKE 'Single Family%' 
           AND match_category <> 'Single address (mailable)'
        THEN 'Unexpected'

      WHEN LandUse IN ('Duplex (2 Family)', 'Multi-Family', 'Mixed-Use')
           AND match_category LIKE 'Multiple addresses%'
        THEN 'Expected'
      WHEN LandUse IN ('Duplex (2 Family)', 'Multi-Family', 'Mixed-Use')
           AND match_category NOT LIKE 'Multiple addresses%'
        THEN 'Unexpected'

      WHEN LandUse IN ('Commercial','Office','Institutional')
           AND match_category IN ('Multiple addresses (many mailable)',
                                  'Single address (mailable)')
        THEN 'Expected'
      WHEN LandUse IN ('Commercial','Office','Institutional')
           AND match_category NOT IN ('Multiple addresses (many mailable)',
                                      'Single address (mailable)')
        THEN 'Unexpected'

      WHEN LandUse IN ('Vacant','Public-Open Space')
           AND match_category LIKE '%not mailable%'
        THEN 'Expected'
      WHEN LandUse IN ('Vacant','Public-Open Space')
           AND match_category NOT LIKE '%not mailable%'
        THEN 'Unexpected'

      ELSE 'Review'
    END AS expectation_flag
  FROM summary
)
SELECT
  LandUse,
  PropertyClass,
  COUNT(*) FILTER (WHERE expectation_flag = 'Expected')   AS expected_count,
  COUNT(*) FILTER (WHERE expectation_flag = 'Unexpected') AS unexpected_count,
  COUNT(*) FILTER (WHERE expectation_flag = 'Review')     AS review_count,
  COUNT(*)                                               AS total_count
FROM flagged
GROUP BY LandUse, PropertyClass
ORDER BY LandUse, total_count DESC, PropertyClass;
""",pageLength=100);
```

## Finally, create interim table

```{python}
x = con.execute("""
-- Step 1: join parcels and addresses
CREATE OR REPLACE TABLE parcel_address_join AS
SELECT
    p.ParcelID,
    p.PIN,
    p.OwnerName,
    p.MailAddress,
    p.MailCity,
    p.MailState,
    p.MailZip,
    p.AssessmentDate,
    p.LandValue,
    p.DwellingValue,
    p.TotalValue,
    p.LandSqFt,
    p.PropertyClassID,
    p.PropertyClass,
    p.LandUse,
    p.OwnerOccupied,
    p.FanUse,
    p.FanUseType,
    p.FanUseOrder,
    p.geometry AS parcel_geometry,

    a.AddressId,
    a.AddressLabel,
    a.BuildingNumber,
    a.StreetDirection,
    a.StreetName,
    a.StreetType,
    a.ExtensionWithUnit,
    a.UnitType,
    a.UnitValue,
    a.ZipCode,
    a.Mailable,
    a.StatePlaneX,
    a.StatePlaneY,
    a.Latitude,
    a.Longitude,
    a.geometry AS address_geometry,

    -- Add helper flags
    (CASE WHEN a.Mailable = 'Yes' THEN 1 ELSE 0 END) AS is_mailable
FROM parcels p
LEFT JOIN addresses a
  ON ST_Within(a.geometry, p.geometry);   -- adjust join rule if you used XY coords
""");
```


```{python}
x = con.execute("""
CREATE OR REPLACE TABLE parcel_address_join_with_flags AS
WITH classified AS (
  SELECT
    ParcelID,
    LandUse,
    PropertyClass,
    COUNT(DISTINCT AddressId) AS address_count,
    SUM(is_mailable) AS mailable_count
  FROM parcel_address_join
  GROUP BY ParcelID, LandUse, PropertyClass
),
flags AS (
  SELECT
    c.*,
    CASE
      WHEN address_count = 0 THEN 'No match'
      WHEN address_count = 1 AND mailable_count = 1 THEN 'Single address (mailable)'
      WHEN address_count = 1 AND mailable_count = 0 THEN 'Single address (not mailable)'
      WHEN address_count > 1 AND mailable_count = 1 THEN 'Multiple addresses (1 mailable)'
      WHEN address_count > 1 AND mailable_count > 1 THEN 'Multiple addresses (many mailable)'
      WHEN address_count > 1 AND mailable_count = 0 THEN 'Multiple addresses (none mailable)'
      ELSE 'Unclassified'
    END AS match_category
  FROM classified c
),
label_counts AS (
  SELECT 
    AddressLabel,
    COUNT(DISTINCT ParcelID) AS label_parcel_count
  FROM parcel_address_join
  GROUP BY AddressLabel
)
SELECT
  j.*,
  f.address_count,
  f.mailable_count,
  f.match_category,
  CASE
    WHEN j.LandUse LIKE 'Single Family%' 
         AND f.match_category = 'Single address (mailable)' THEN 'Expected'
    WHEN j.LandUse LIKE 'Single Family%' 
         AND f.match_category <> 'Single address (mailable)' THEN 'Unexpected'

    WHEN j.LandUse IN ('Duplex (2 Family)','Multi-Family','Mixed-Use')
         AND f.match_category LIKE 'Multiple addresses%' THEN 'Expected'
    WHEN j.LandUse IN ('Duplex (2 Family)','Multi-Family','Mixed-Use')
         AND f.match_category NOT LIKE 'Multiple addresses%' THEN 'Unexpected'

    WHEN j.LandUse IN ('Commercial','Office','Institutional')
         AND f.match_category IN ('Multiple addresses (many mailable)','Single address (mailable)') THEN 'Expected'
    WHEN j.LandUse IN ('Commercial','Office','Institutional')
         AND f.match_category NOT IN ('Multiple addresses (many mailable)','Single address (mailable)') THEN 'Unexpected'

    WHEN j.LandUse IN ('Vacant','Public-Open Space')
         AND f.match_category LIKE '%not mailable%' THEN 'Expected'
    WHEN j.LandUse IN ('Vacant','Public-Open Space')
         AND f.match_category NOT LIKE '%not mailable%' THEN 'Unexpected'

    ELSE 'Review'
  END AS expectation_flag,
  l.label_parcel_count
FROM parcel_address_join j
JOIN flags f USING (ParcelID, LandUse, PropertyClass)
LEFT JOIN label_counts l USING (AddressLabel);
"""
)
```


```{python}

x = con.execute("""
CREATE OR REPLACE TABLE parcel_address_join_with_flags AS
SELECT
    *,
    REGEXP_REPLACE(AddressLabel, '(?i)\\bApt\\b', 'Unit') AS AddressLabel_1
FROM parcel_address_join_with_flags;
""")
df = con.execute("SELECT * FROM parcel_address_join_with_flags").fetchdf()
df.to_parquet("ParcelAddressJoin_in_fan.parquet", engine="pyarrow") 
show(df,pageLength=5)
```
## Data Dictionary

Perfect 👍 — here’s a **full schema documentation** for `parcel_address_join_with_flags`, structured for readability and ready to drop into a README, Quarto doc, or data dictionary.

---

# 📑 Table Schema: `parcel_address_join_with_flags`

**Description**
This table links **Parcels** (tax assessment records) with **Addresses** (city-recognized mailing addresses), enriched with classification fields and quality-control flags.

* **One row for every Parcel ↔ Address combination**.
* Contains all relevant attributes from both source datasets plus derived fields for analysis.
* Stored in Parquet (`ParcelAddressJoin_in_fan.parquet`) for reuse.

---

## 1. Parcel Attributes

(From the *Parcels* dataset)

| Column            | Type     | Description                                                                                    |
| ----------------- | -------- | ---------------------------------------------------------------------------------------------- |
| `ParcelID`        | INTEGER  | Unique parcel identifier in the city GIS.                                                      |
| `PIN`             | VARCHAR  | Parcel Identification Number (tax lot ID).                                                     |
| `CountOfPIN`      | INTEGER  | Number of PINs associated with this parcel (multi-PIN parcels).                                |
| `OwnerName`       | VARCHAR  | Name of the current owner of the parcel.                                                       |
| `MailAddress`     | VARCHAR  | Mailing street address of the owner (may differ from property location).                       |
| `MailCity`        | VARCHAR  | City portion of the owner’s mailing address.                                                   |
| `MailState`       | VARCHAR  | State portion of the owner’s mailing address.                                                  |
| `MailZip`         | VARCHAR  | ZIP code of the owner’s mailing address.                                                       |
| `AssessmentDate`  | VARCHAR  | Date of most recent assessment.                                                                |
| `LandValue`       | DOUBLE   | Assessed land value.                                                                           |
| `DwellingValue`   | DOUBLE   | Assessed building value.                                                                       |
| `TotalValue`      | DOUBLE   | Total assessed value.                                                                          |
| `LandSqFt`        | DOUBLE   | Parcel land area in square feet.                                                               |
| `ProvalAsmtNhood` | VARCHAR  | Assessment neighborhood code.                                                                  |
| `TaxExemptCode`   | VARCHAR  | Tax exemption code (if applicable).                                                            |
| `PropertyClassID` | VARCHAR  | Internal property classification ID.                                                           |
| `PropertyClass`   | VARCHAR  | Human-readable property classification (e.g., *R Two Story*, *B Commercial Common Area Main*). |
| `LandUse`         | VARCHAR  | Land use category (e.g., *Single Family*, *Multi-Family*, *Commercial*, *Vacant*).             |
| `OwnerOccupied`   | BIGINT   | Flag (1/0) if the property is owner-occupied.                                                  |
| `FanUse`          | VARCHAR  | Local neighborhood-specific use classification.                                                |
| `FanUseType`      | VARCHAR  | Derived Fan District use type (e.g., *FanOwner*, *FanRenter*).                                 |
| `FanUseOrder`     | BIGINT   | Ordering value for FanUse categories.                                                          |
| `parcel_geometry` | GEOMETRY | Polygon geometry of the parcel boundary.                                                       |

---

## 2. Address Attributes

(From the *Addresses* dataset)

| Column              | Type     | Description                                                                 |
| ------------------- | -------- | --------------------------------------------------------------------------- |
| `AddressId`         | VARCHAR  | Unique address record identifier.                                           |
| `AddressLabel`      | VARCHAR  | Formatted mailing address (human-readable, e.g. *401 N Robinson St Apt A*). |
| `BuildingNumber`    | VARCHAR  | Street/building number.                                                     |
| `StreetDirection`   | VARCHAR  | Street direction (e.g., N, S, E, W).                                        |
| `StreetName`        | VARCHAR  | Street name.                                                                |
| `StreetType`        | VARCHAR  | Street type (e.g., St, Ave, Blvd).                                          |
| `ExtensionWithUnit` | VARCHAR  | Address extension (e.g., *Rear*, *Suite*, *Apt*).                           |
| `UnitType`          | VARCHAR  | Unit type (e.g., *Apt*, *Unit*, *Suite*).                                   |
| `UnitValue`         | VARCHAR  | Unit number or identifier.                                                  |
| `ZipCode`           | VARCHAR  | Postal ZIP code.                                                            |
| `Mailable`          | VARCHAR  | “Yes” if USPS deliverable, “No” otherwise.                                  |
| `StatePlaneX`       | DOUBLE   | X coordinate (State Plane projection).                                      |
| `StatePlaneY`       | DOUBLE   | Y coordinate (State Plane projection).                                      |
| `Latitude`          | DOUBLE   | Latitude coordinate (WGS84).                                                |
| `Longitude`         | DOUBLE   | Longitude coordinate (WGS84).                                               |
| `address_geometry`  | GEOMETRY | Point geometry of the address location.                                     |

---

## 3. Derived Fields (Flags and Counts)

| Column               | Type    | Description                                                                                                                                                                                                                                                                                                         |
| -------------------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `is_mailable`        | INTEGER | 1 if `Mailable = 'Yes'`, else 0.                                                                                                                                                                                                                                                                                    |
| `address_count`      | INTEGER | Number of addresses linked to the parcel.                                                                                                                                                                                                                                                                           |
| `mailable_count`     | INTEGER | Number of mailable addresses linked to the parcel.                                                                                                                                                                                                                                                                  |
| `match_category`     | VARCHAR | Classification of parcel–address relationship. Possible values: <br> - `No match` <br> - `Single address (mailable)` <br> - `Single address (not mailable)` <br> - `Multiple addresses (1 mailable)` <br> - `Multiple addresses (many mailable)` <br> - `Multiple addresses (none mailable)` <br> - `Unclassified`. |
| `expectation_flag`   | VARCHAR | Quality flag comparing `match_category` against `LandUse` expectations. Possible values: <br> - `Expected` <br> - `Unexpected` <br> - `Review`.                                                                                                                                                                     |
| `label_parcel_count` | INTEGER | Number of distinct parcels sharing the same `AddressLabel`.                                                                                                                                                                                                                                                         |

---

## 4. Row Semantics

* Each row = **one parcel–address combination**.
* Parcels with multiple addresses → appear multiple times.
* Addresses tied to multiple parcels (rare, e.g., condos, common-area splits) → appear multiple times.
* Together, this table enables analysis at the **parcel-level**, **address-level**, or **household-level**.

---

✅ With this schema, you can:

* Join members (by `AddressLabel` or `AddressId`) and check anomalies (`expectation_flag`).
* Collapse to households (using `AddressLabel`, `label_parcel_count`).
* Do penetration analysis across `LandUse` / `PropertyClass`.

---

👉 Do you want me to also sketch a **schema diagram** (like an ERD-style box with key columns and relationships between parcels, addresses, and the join) so you have a visual to drop into documentation?


## How many rows share the same AddressLabel?

```{python}
x = con.execute("""
create or replace table parcel_address_join_with_flags as
SELECT * FROM 'ParcelAddressJoin_in_fan.parquet';
""")
```

```{python}
#| output: asis
show_result_set("""
SELECT
    AddressLabel,
    COUNT(DISTINCT ParcelID) AS parcel_count,
    COUNT(DISTINCT AddressId) AS addressid_count,
    COUNT(*) AS join_rows
FROM parcel_address_join_with_flags
GROUP BY AddressLabel
HAVING COUNT(DISTINCT ParcelID) > 1
ORDER BY parcel_count DESC;

""",pageLength=100);
```

# Working with Contacts


```{python}
fda_contacts_filename = get_newest_file( precious_folder,'FDA_contacts',ext='.csv')

contacts = pd.read_csv(fda_contacts_filename).drop(index=0).reset_index(drop=True)

# Dictionary of replacements
street_replacements = {
    "AVENUE": "AVE",
    "ALLEY" : "AL",
    "PLACE": "PL",
    "STREET": "ST",
    "ROAD": "RD",
    "BOULEVARD": "BLVD",
    "COURT": "CT",
    "DRIVE": "DR",
    "LN" : "LANE",
    "CIRCLE" : "CIR",
    "APARTMENT" : "APT"

}

def normalize_address(addr, addr2=""):
    if pd.isna(addr) or str(addr).strip() == "":
        return ""
    addr = addr.upper().strip()
    addr = addr.replace(".#", " ")
    addr = addr.replace(" #6C", " UNIT 6C")

    addr = addr.replace(".", "")
    addr = addr.replace(",", "")
    addr = addr.replace("#", "")
    addr = addr.replace("’", " ")

    addr = addr.replace("1509HANOVER","1509 HANOVER")
    addr = addr.replace("1529’W","1529 W")
    addr = addr.replace("DAVISAVE","DAVIS AVE")
    if addr.endswith("MEADOW"):
        addr = addr.replace("MEADOW","MEADOW AVE")

    # Detect "101A" pattern (building number with unit letter)
    m = re.match(r"^(\d+)\s*([A-D])\s+(.*)", addr)
    if m:
        number, unit, rest = m.groups()
        addr = f"{number} {rest} UNIT {unit}"

    # Inline unit numbers
    addr = re.sub(r"\s+#(\w+)$", r" UNIT \1", addr)
    addr = addr.replace(",","")

    # Replace street types at word boundaries
    for long, short in street_replacements.items():
        addr = re.sub(rf"\b{long}\b", short, addr)

    # List of street types you don't want to accidentally collapse
    protected_types = ["AVE", "ST", "PL", "RD", "BLVD", "CT", "DR", "LN", "TER"]

    # Build regex that says "only abbreviate if WEST is not followed by a street type"
    protected_regex = "|".join(protected_types)

    addr = re.sub(rf"^(\d+)\s+NORTH(?!\s+({protected_regex})\b)", r"\1 N", addr)
    addr = re.sub(rf"^(\d+)\s+SOUTH(?!\s+({protected_regex})\b)", r"\1 S", addr)
    addr = re.sub(rf"^(\d+)\s+EAST(?!\s+({protected_regex})\b)",  r"\1 E", addr)
    addr = re.sub(rf"^(\d+)\s+WEST(?!\s+({protected_regex})\b)",  r"\1 W", addr)

    
    # Add Address Line 2 if present
    if pd.notna(addr2) and str(addr2).strip() != "":
        addr2_norm = addr2.upper().strip().replace(".", "")
        addr2_norm = addr2_norm.replace("#", "").strip()  # remove #
        addr2_norm = addr2_norm.replace("-", "").strip()  # remove #
        addr2_norm = re.sub(r"\bAPARTMENT\b", "UNIT", addr2_norm)  # normalize APARTMENT → UNIT
        # If it's just a single word (no spaces), prepend "UNIT " unless it already has APT/UNIT
        if " " not in addr2_norm and not addr2_norm.startswith(("UNIT", "APT")):
            addr2_norm = f"UNIT {addr2_norm}"

        for long, short in street_replacements.items():
            addr2_nrom = re.sub(rf"\b{long}\b", short, addr2_norm)
            
        addr2_norm = addr2_norm.replace("KAVACLUB","")
        addr2_norm = addr2_norm.replace("RICHMOND, VA","")
        addr2_norm = addr2_norm.replace("WARSAW CONDOS","")
        addr2_norm = addr2_norm.replace("U10B","UNIT 10B")
        addr2_norm = addr2_norm.replace("U-PL-F","PL-F")
        addr = addr + " " + addr2_norm

    # Special cases
    if addr.endswith(" DUBOIS"):
        addr = addr + " AVE"

    addr = addr.replace("APT","UNIT")
    # Collapse multiple spaces
    addr = re.sub(r"\s+", " ", addr).strip()

    return addr


# Apply
contacts["AddressLabel_norm"] = contacts.apply(
    lambda row: normalize_address(row["Address"], row.get("Address Line 2", "")),
    axis=1
)

# Normalize Zip
contacts["Zip_norm"] = contacts["Zip"].astype(str).str.strip().str.upper()

contacts.to_parquet("fda_contacts_normalized.parquet", index=False)

```



```{python}
#| output: asis
show_result_set("""
CREATE OR REPLACE TABLE fda_contacts_normalized AS
SELECT * FROM 'fda_contacts_normalized.parquet';
""",pageLength=100);
```

```{python}
#| output: asis
show_result_set("""
CREATE OR REPLACE TABLE fda_contacts_matched AS
SELECT
    c.*,
    j.ParcelID         AS MatchedParcelID,
    j.LandUse          AS MatchedLandUse,
    j.PropertyClass    AS MatchedPropertyClass,
    j.match_category   AS MatchCategory,
    j.expectation_flag AS ExpectationFlag,
    j.label_parcel_count AS LabelParcelCount,
    CASE 
        WHEN c.Address IS NULL OR trim(c.Address) = '' 
            THEN 'Blank Address'
        WHEN c.Zip_norm NOT IN ('23220','23284')
            THEN 'Zip not in Fan'
        WHEN j.ParcelID IS NOT NULL 
            THEN 'Matched'
        ELSE 'Unmatched'
    END AS MatchStatus
FROM fda_contacts_normalized c
LEFT JOIN parcel_address_join_with_flags j
  ON c.AddressLabel_norm <> ''
 AND j.AddressLabel_1 IS NOT NULL AND j.AddressLabel_1 <> ''
 AND c.AddressLabel_norm = upper(j.AddressLabel_1)
 AND c.Zip_norm = j.ZipCode;
""",pageLength=100);
```

```{python}
df1 = con.execute("select * from fda_contacts_matched").fetch_df()
df2 = con.execute("select * from parcel_address_join_with_flags").fetch_df()
```



```{python}
#| output: asis
show_result_set("""
SELECT 
    MatchStatus,
    COUNT(*) AS total,
    SUM(CASE WHEN Member = 'True' THEN 1 ELSE 0 END) AS member_yes,
    SUM(CASE WHEN Member = 'False'  THEN 1 ELSE 0 END) AS member_no
FROM fda_contacts_matched
GROUP BY MatchStatus
ORDER BY MatchStatus;
""",pageLength=100);
```


## UnMatched contacts


```{python}
#| output: asis
show_result_set("""
SELECT 
    upper(AddressLabel_norm) as FDA_Address,
    Member
FROM fda_contacts_matched
WHERE MatchStatus = 'Unmatched' and Member='True'
ORDER BY upper(AddressLabel_norm)
""",pageLength=10);
```

```{python}
#| output: asis
show_result_set("""
select 
--UPPER(AddressLabel_1) as PAJ_Address,FanUse,FanUseType, ParcelID,AddressID
*
from parcel_address_join_with_flags
order by upper(AddressLabel_1)
""",pageLength=2);
```

```{python}
#| output: asis
show_result_set("""
describe fda_contacts_matched
""",pageLength=100);
```

