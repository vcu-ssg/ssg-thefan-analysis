---
title: setup
---

This is the introduction paragraph.  In this file we're cleaning the data and setting up files for later processing.

```{python}


import os
import re
import sys
import sqlite3
import requests
import numpy as np
import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt

from matplotlib.patches import Patch
from matplotlib.lines import Line2D
from math import floor

from loguru import logger
# Configure loguru to only log to stderr (console)
logger.remove()  # remove default handler
logger.add(sys.__stderr__, level="INFO", format="{level: <8} | {name}:{function}:{line} - {message}" )  # use the original stderr, not Jupyter’s proxy

## Set up itables
import itables
from itables import show
# 🔧 Sensible global defaults for itables
itables.options.maxBytes = 0                        # show full content in each cell
itables.options.classes = ["display", "compact"]    # compact, clean look
itables.options.lengthMenu = [10, 25, 50, 100]      # page length menu
itables.options.pageLength = 25
itables.options.buttons = ["copy", "csv", "print"]
itables.options.scrollX = True                      # allow horizontal scroll if needed
itables.options.scrollY = True                      # allow horizontal scroll if needed
itables.options.ordering = True

## Set up duckdb

import duckdb
con = duckdb.connect()
x = con.execute("INSTALL spatial; LOAD spatial;")

sys.path.append("..")
from fandu.geo_utils import get_newest_file

pd.set_option("display.max_rows", None)

precious_folder = "../precious/"
features = ["Addresses","Parcels"]
selector = "Civic_Associations"
selector_key = "Fan District Association"

fda_contacts_filename = get_newest_file( precious_folder,'FDA_contacts',ext='.csv')

```
```{python}

def show_result_set( query, **kwargs ):
    print('::: {.column-screen-inset style="font-size:0.7em"}')
    df = con.execute( query ).fetch_df()
    show(df,**kwargs)
    print(':::')

```

# Load, clean, recode and save

## Load files

```{python}
#| echo: true

# Load the neighborhoods GeoJSON
# creates data["Parcels"] containing geojson data.
data = {}
for feature in [selector] + features:
    geofile = get_newest_file( precious_folder, feature, ext=".geojson" )
    #logger.debug(geofile)
    logger.info(f"Found {feature}:  {geofile}" )
    data[feature] = gpd.read_file( geofile )

# convert all feature files to same CRS mapping as Civic_Associations
for feature in features:
    data[feature] = data[feature].to_crs( data[selector].crs )

```

### Drop columns

```{python}
#| echo: true
# columns to drop:
shared_drops = ['CreatedBy','CreatedDate','EditBy','EditDate']
## file specific column drop mappings
drop_columns = {
    "Civic_Associations" : ['OBJECTID'] + shared_drops,
    "Addresses"          : ['OBJECTID'] + shared_drops,
    "Parcels"            : ['OBJECTID'],
}
for feature in [selector] + features:
    data[feature] = data[feature].drop(columns=drop_columns[feature])

```

### Spatial join, select only parcels and addresses in the Fan.

```{python}
#| echo: true

# Pull out only FDA from Civic_Associations and store it
data[selector_key] = data[selector][ data[selector]["Name"] == selector_key ]

# Select only features from the selector_key (FDA).  perform spatial join.
for feature in features:
    predicate = "overlaps" if feature=="Neighborhoods" else "within"
    data[feature+"_in_fan"] = gpd.sjoin(data[feature], data[selector_key], predicate=predicate, how="inner")

```

### Drop unnecessary columns

```{python}
#| echo: true
# Drop columns created from spatial join
shared_drops = ["index_right","AdoptionDate","ChangeDate","Shape__Area","Shape__Length"]
drop_columns = {
    "Addresses"          : ['GlobalID'] + shared_drops,
    "Parcels"            : ['MaskedOwner','GlobalID_left','GlobalID_right'] + shared_drops,
}
for feature in features:
    feature_name = feature+"_in_fan"
    data[feature_name] = data[feature_name].drop(columns=drop_columns[feature])
```

### Create columns and recode columns in Parcels

```{python}
#| echo: true

gdf = data["Parcels_in_fan"]

gdf["OwnerOccupied"] = gdf.apply(
    lambda row: str(row["MailAddress"]).startswith(str(row["AsrLocationBldgNo"]))
                and str(row["MailCity"]).upper() == "RICHMOND"
                and str(row["MailState"]).upper() == "VA"
                and str(row["MailZip"]) == "23220",
    axis=1
).map({True: 1, False: 0})


# Rule 1: If PropertyClass contains 'Commercial'
gdf.loc[gdf["PropertyClass"].str.contains("Commercial", case=False, na=False), "LandUse"] = "Commercial"

# Rule 2: If PropertyClass contains 'Condo'
gdf.loc[gdf["PropertyClass"].str.contains("Condo", case=False, na=False), "LandUse"] = "Multi-Family"

gdf["SharedGeometry"] = gdf.duplicated(subset="geometry", keep=False).astype(int)

# Create FanUse

mapping = {
    "Single Family": "FanResidential",
    "Multi-Family": "FanResidential",
    "Duplex (2 Family)" : "FanResidential",
    "Commercial": "FanBusiness",
    "Industrial": "FanBusiness",
    "Office" : "FanBusiness",
    "Institutional" : "FanBusiness",
    "Mixed-Use" : "FanMixed-Use"
}
gdf["FanUse"] = gdf["LandUse"].map(mapping).fillna("FanOther")

# Ensure PropertyClass is string and safe for NaNs
mask = gdf["PropertyClass"].fillna("").str.contains("vacant|parking|common|garage|storage|tower|space", case=False, na=False)
# Apply recode
gdf.loc[mask, "FanUse"] = "FanOther"


# A new variable to permit easy selecting

gdf["FanUseType"] = "FanIgnore"  # default
gdf.loc[(gdf["OwnerOccupied"] == 1) & (gdf["Mailable"] == 1), "FanUseType"] = "FanOwner"
gdf.loc[(gdf["OwnerOccupied"] == 0) & (gdf["Mailable"] == 1), "FanUseType"] = "FanRental"

# Reset if it's one of the FanOther property classes.
gdf.loc[mask, "FanUseType"] = "FanIgnore"


mapping = {
    "FanResidential": 1,
    "FanBusiness": 10,
    "FanMixed-Use" : 20,
    "FanOther": 99
}
gdf["FanUseOrder"] = gdf["FanUse"].map(mapping).fillna(99)

data["Parcels_in_fan"] = gdf

```

### Clean columns in Addresses

```{python}
gdf = data["Addresses_in_fan"]

# Trim and normalize white space
gdf = gdf.apply(lambda col: col.str.strip() if col.dtype == "object" else col)
gdf = gdf.apply(lambda col: col.str.strip().str.replace(r"\s+", " ", regex=True) 
                if col.dtype == "object" else col)

# Make sure values are integers, or compare as strings consistently
gdf.loc[~gdf["ZipCode"].isin(['23220', '23284']), "ZipCode"] = '23220'

## New columns
gdf["AddressBase"] = (
    gdf["BuildingNumber"].fillna("").astype(str).str.strip() + " " +
    gdf["StreetDirection"].fillna("").astype(str).str.strip() + " " +
    gdf["StreetName"].fillna("").astype(str).str.strip() + " " +
    gdf["StreetType"].fillna("").astype(str).str.strip()
).str.replace(r"\s+", " ", regex=True).str.strip()


def make_extension(row):
    parts = []
    # only include UnitType if it's not None, empty, or "None"
    if row["UnitType"] not in [None, "", "None"]:
        parts.append(str(row["UnitType"]).strip())
    # only include UnitValue if it's not None or empty
    if row["UnitValue"] not in [None, ""]:
        parts.append(str(row["UnitValue"]).strip())
    return " ".join(parts)
gdf["AddressExtension"] = gdf.apply(make_extension, axis=1)

data["Addresses_in_fan"] = gdf
```

### Save Parcels_in_fan and Addresses_in_fan for later use.

```{python}
#| echo: true
for feature in features:
    feature_name = feature+"_in_fan"

    # store to parquet using pyarror (workflow tip from chatgpt
    data[feature_name].to_parquet(f"{feature_name}.parquet",engine="pyarrow")
    logger.info(f"Saving: {feature_name}.parquet" )

    # create dataframe without spatial geometries and store to CSV
    gdf = data[feature_name].drop(columns="geometry")
    gdf.to_csv(f"{feature_name}.csv", index=False)
    logger.info(f"Saving: {feature_name}.csv" )


```

# Examine Addresses

In the following sections we review the Addresses file.  If changes
are necessary, iterate with the cleaning sections and rerun the report until
everyting is clean.

```{python}
x = con.execute("CREATE OR REPLACE TABLE addresses AS SELECT * FROM 'Addresses_in_fan.parquet';")
```

## List count addresses by zipcode
```{python}
#| output: asis
show_result_set("""
select 
  ZipCode,
  count(*)
from
  addresses
group by
  ZipCode
order by
  ZipCode
""",pageLength=10)
```

## List odd addresses

This should return blank.  These were cleaned/fixed above.

```{python}
#| output: asis
#| echo: true
show_result_set("""
select 
  *
from
  addresses
where
  not ZipCode in ('23220','23284')
order by
  StreetName,AddressLabel

""",pageLength=10)
```


## List of Street Names

```{python}
#| output: asis
show_result_set("""
select StreetName from addresses group by StreetName order by StreetName
""",pageLength=10)
```

## List AddressLabels with mismatched AddressBase 

```{python}
#| output: asis
show_result_set("""
SELECT *
FROM addresses
WHERE AddressLabel NOT LIKE AddressBase || '%';
""",pageLength=10)
```

## List Addresses with mismatched AddressExtension

```{python}
#| output: asis
show_result_set("""
SELECT 
  '"' || AddressLabel || '"',
  '"' || AddressBase || '"',
  '"' || AddressExtension || '"',
  len(addresslabel),
  len(addressbase),
  len(addressextension)
FROM addresses
WHERE AddressLabel NOT LIKE ('% ' || AddressExtension || '%')
  AND AddressExtension IS NOT NULL 
  AND AddressExtension <> '';
""",pageLength=10)
```

## List addresses that don't add up

```{python}
#| output: asis
show_result_set("""
SELECT 
  '"' || AddressLabel || '"',
  '"' || AddressBase || '"',
  '"' || AddressExtension || '"',
  len(addresslabel),
  len(addressbase),
  len(addressextension)
FROM addresses
WHERE (AddressLabel <> AddressBase || ' ' || AddressExtension
  AND AddressExtension IS NOT NULL 
  AND AddressExtension <> '')
  or (AddressLabel='401 N Robinson St');
""",pageLength=10)
```
## List of valid unit types

```{python}
#| output: asis
show_result_set("""
WITH unittype_cte AS (
    SELECT unittype
    FROM addresses
    WHERE not unittype in ('None','')
    GROUP BY unittype
)
SELECT * from unittype_cte
""",pageLength=10)
```

## List of Addresses with unittype in AddressLabel and missing ExtensionWithUnit

```{python}
#| output: asis
show_result_set("""
WITH unittype_cte AS (
    SELECT unittype
    FROM addresses
    WHERE unittype <> 'None'
    GROUP BY unittype
)
SELECT
    a.AddressLabel,
    a.AddressBase,
    a.AddressExtension,
    a.ExtensionWithUnit,
    a.UnitType,
    a.UnitValue
FROM addresses a
WHERE 
  ((a.ExtensionWithUnit IS NULL OR a.ExtensionWithUnit = '')
    or (a.UnitType is NULL or a.UnitType='' or a.UnitType='None') )
  and regexp_matches(AddressLabel, '\\bSte\\b');
""",pageLength=10)
```


## View All Addresses

::: {.column-screen-inset style="font-size:0.7em"}
```{python}
df = con.execute("""
select * from addresses
""").fetch_df().drop(columns=["geometry","__index_level_0__"])
show(df,pageLength=10)
```
:::


# Examine Parcels

```{python}
x = con.execute("CREATE TABLE parcels AS SELECT * FROM 'Parcels_in_fan.parquet';")
```

## FanUse by FanUseType

::: {style="font-size:0.7em"}

```{python}
result = con.execute("""
SELECT
    FanUse,
    SUM(CASE WHEN FanUseType='FanOwner'  THEN 1 ELSE 0 END) AS FanOwner,
    SUM(CASE WHEN FanUseType='FanRental' THEN 1 ELSE 0 END) AS FanRental,
    SUM(CASE WHEN FanUseType='FanIgnore' THEN 1 ELSE 0 END) AS FanIgnore,
    SUM(1) as total,
    ' ' as ' ',
    SUM(CASE WHEN SharedGeometry = 1 THEN 1 ELSE 0 END) AS SharedParcel
FROM parcels
GROUP BY FanUse,FanUseOrder
ORDER BY FanUseOrder
""").fetch_df().reset_index()
show(result,pageLength=100)
```
:::

* `FanOwner` - Parcel owner address matches building address number, parcel owner zip is 23220, and parcel has mailable USPS address for owner of record.  These parcel owners have their tax
record mailed to this parcel address, so they're probably the owner.
* `FanRental` - Parcel owner address doesn't match building address number. So, parcel owner address is OUTSIDE the Fan. It's possible that the owner uses a different address for tax bill. NOTE - the parcel database doesn't contain addresses for these parcels. We don't have Fan addresses for these parcels, just the address of the tax owner.  For example, the address for Joe's Inn isn't in parcel database.  The parcel owner is outside the Fan.
* `FanIgnore` - not a mailable address, probably a park, parking lot, common area, etc.


## FanUse, LandUse by FanUseType


::: {.column-page-inset-right style="font-size:0.7em"}

```{python}
result = con.execute("""
SELECT
    FanUse, LandUse,
    SUM(CASE WHEN FanUseType='FanOwner'  THEN 1 ELSE 0 END) AS FanOwner,
    SUM(CASE WHEN FanUseType='FanRental' THEN 1 ELSE 0 END) AS FanRental,
    SUM(CASE WHEN FanUseType='FanIgnore' THEN 1 ELSE 0 END) AS FanIgnore,
    SUM(1) as total,
    ' ' as ' ',
    SUM(CASE WHEN SharedGeometry = 1 THEN 1 ELSE 0 END) AS SharedParcel
FROM parcels
GROUP BY FanUse,LandUse,FanUseOrder
ORDER BY FanUseOrder, LandUse
""").fetch_df().reset_index()
show(result,pageLength=100)
```
:::

## FanUse, LandUse, PropertyClass by FanUseType

::: {.column-page-inset-right style="font-size:0.7em"}
```{python}
result = con.execute("""
SELECT
    FanUse, LandUse, PropertyClass,
    SUM(CASE WHEN FanUseType='FanOwner'  THEN 1 ELSE 0 END) AS FanOwner,
    SUM(CASE WHEN FanUseType='FanRental' THEN 1 ELSE 0 END) AS FanRental,
    SUM(CASE WHEN FanUseType='FanIgnore' THEN 1 ELSE 0 END) AS FanIgnore,
    SUM(1) as total,
    ' ' as ' ',
    SUM(CASE WHEN SharedGeometry = 1 THEN 1 ELSE 0 END) AS SharedParcel
FROM parcels
GROUP BY FanUse,LandUse,FanUseOrder,PropertyClass
ORDER BY FanUseOrder, LandUse, PropertyClass
""").fetch_df().reset_index()
show(result,pageLength=100)
```
:::


## View All Parcels

Use the Sort field to select subsets of parcels.

::: {.column-screen-inset style="font-size:0.7em"}
```{python}
feature_name = "Parcels_in_fan"
df = data[feature_name].drop(columns="geometry")
cols = ["FanUse", "LandUse", "PropertyClass","FanUseType"] + [c for c in df.columns if c not in ["FanUse", "LandUse", "PropertyClass"]]
df = df[cols]               
df = df.sort_values(by=["FanUseOrder", "LandUse", "PropertyClass"],
               ascending=[True, True, True])
show(df)
```
:::

# Create merge file

```{python}
x = con.execute("""
CREATE OR REPLACE TABLE addresses AS SELECT * FROM 'Addresses_in_fan.parquet';
CREATE OR REPLACE TABLE parcels AS SELECT * FROM 'Parcels_in_fan.parquet';
""");
```

```{python}
#| output: asis

x = con.execute("""
CREATE OR REPLACE TABLE parcel_address_join AS
SELECT 
    p.ParcelID,
    p.PIN,
    p.AsrLocationBldgNo,
    p.OwnerName,
    p.MailAddress,
    a.AddressId,
    a.BuildingNumber,
    a.StreetName,
    a.Mailable AS AddressMailable,
    p.LandUse,
    p.PropertyClass,
    p.geometry AS parcel_geom,
    a.geometry AS addr_geom
FROM parcels p
LEFT JOIN addresses a
  ON ST_Within(a.geometry, p.geometry);
""")
```

```{python}
#| output: asis
show_result_set("""
WITH classified AS (
  SELECT 
    ParcelID,
    COUNT(DISTINCT AddressId) AS address_count,
    COUNT_IF(AddressMailable = 'Yes') AS mailable_count
  FROM parcel_address_join
  GROUP BY ParcelID
)
SELECT
  CASE
    WHEN address_count = 0 THEN 'No match'
    WHEN address_count = 1 AND mailable_count = 1 THEN 'Single address (mailable)'
    WHEN address_count = 1 AND mailable_count = 0 THEN 'Single address (not mailable)'
    WHEN address_count > 1 AND mailable_count = 1 THEN 'Multiple addresses (1 mailable)'
    WHEN address_count > 1 AND mailable_count > 1 THEN 'Multiple addresses (many mailable)'
    WHEN address_count > 1 AND mailable_count = 0 THEN 'Multiple addresses (none mailable)'
    ELSE 'Unclassified'
  END AS match_category,
  COUNT(*) AS parcel_count
FROM classified
GROUP BY match_category
ORDER BY parcel_count DESC;

""",pageLength=10)
```


```{python}
#| output: asis
show_result_set("""
WITH address_classified AS (
  SELECT 
    AddressId,
    COUNT(DISTINCT ParcelID) AS parcel_count
  FROM parcel_address_join
  GROUP BY AddressId
)
SELECT
  CASE
    WHEN parcel_count = 0 THEN 'No parcel match'
    WHEN parcel_count = 1 THEN 'Single parcel'
    WHEN parcel_count > 1 THEN 'Multiple parcels'
  END AS parcel_category,
  COUNT(*) AS address_count
FROM address_classified
GROUP BY parcel_category
ORDER BY address_count DESC;
""",pageLength=10)
```


```{python}
#| output: asis
show_result_set("""
select LandUse, PropertyClass
from parcel_address_join
group by LandUse, PropertyClass
order by LandUse,PropertyClass
""",pageLength=100)
```



```{python}
#| output: asis
show_result_set("""
WITH classified AS (
  SELECT 
    ParcelID,
    LandUse,
    PropertyClass,
    COUNT(DISTINCT AddressId) AS address_count,
    COUNT_IF(AddressMailable = 'Yes') AS mailable_count
  FROM parcel_address_join
  GROUP BY ParcelID, LandUse, PropertyClass
)
SELECT
  LandUse,
  PropertyClass,
  CASE
    WHEN address_count = 0 THEN 'No match'
    WHEN address_count = 1 AND mailable_count = 1 THEN 'Single address (mailable)'
    WHEN address_count = 1 AND mailable_count = 0 THEN 'Single address (not mailable)'
    WHEN address_count > 1 AND mailable_count = 1 THEN 'Multiple addresses (1 mailable)'
    WHEN address_count > 1 AND mailable_count > 1 THEN 'Multiple addresses (many mailable)'
    WHEN address_count > 1 AND mailable_count = 0 THEN 'Multiple addresses (none mailable)'
    ELSE 'Unclassified'
  END AS match_category,
  COUNT(*) AS parcel_count
FROM classified
GROUP BY LandUse, PropertyClass, match_category
ORDER BY LandUse, parcel_count DESC;
""",pageLength=150)
```


```{python}
#| output: asis
show_result_set("""
WITH summary AS (
  SELECT
    ParcelID,
    LandUse,
    PropertyClass,
    COUNT(DISTINCT AddressId) AS address_count,
    COUNT_IF(AddressMailable = 'Yes') AS mailable_count,
    CASE
      WHEN COUNT(DISTINCT AddressId) = 0 THEN 'No match'
      WHEN COUNT(DISTINCT AddressId) = 1 AND COUNT_IF(AddressMailable = 'Yes') = 1
        THEN 'Single address (mailable)'
      WHEN COUNT(DISTINCT AddressId) = 1 AND COUNT_IF(AddressMailable = 'Yes') = 0
        THEN 'Single address (not mailable)'
      WHEN COUNT(DISTINCT AddressId) > 1 AND COUNT_IF(AddressMailable = 'Yes') = 1
        THEN 'Multiple addresses (1 mailable)'
      WHEN COUNT(DISTINCT AddressId) > 1 AND COUNT_IF(AddressMailable = 'Yes') > 1
        THEN 'Multiple addresses (many mailable)'
      WHEN COUNT(DISTINCT AddressId) > 1 AND COUNT_IF(AddressMailable = 'Yes') = 0
        THEN 'Multiple addresses (none mailable)'
      ELSE 'Unclassified'
    END AS match_category
  FROM parcel_address_join
  GROUP BY ParcelID, LandUse, PropertyClass
),
flagged AS (
  SELECT
    ParcelID,
    LandUse,
    match_category,
    CASE
      WHEN LandUse LIKE 'Single Family%' AND match_category = 'Single address (mailable)'
        THEN 'Expected'
      WHEN LandUse LIKE 'Single Family%' AND match_category <> 'Single address (mailable)'
        THEN 'Unexpected'
      WHEN LandUse IN ('Duplex (2 Family)', 'Multi-Family', 'Mixed-Use')
           AND match_category LIKE 'Multiple addresses%'
        THEN 'Expected'
      WHEN LandUse IN ('Duplex (2 Family)', 'Multi-Family', 'Mixed-Use')
           AND match_category NOT LIKE 'Multiple addresses%'
        THEN 'Unexpected'
      WHEN LandUse IN ('Commercial','Office','Institutional')
           AND match_category IN ('Multiple addresses (many mailable)','Single address (mailable)')
        THEN 'Expected'
      WHEN LandUse IN ('Commercial','Office','Institutional')
           AND match_category NOT IN ('Multiple addresses (many mailable)','Single address (mailable)')
        THEN 'Unexpected'
      WHEN LandUse IN ('Vacant','Public-Open Space')
           AND match_category LIKE '%not mailable%'
        THEN 'Expected'
      WHEN LandUse IN ('Vacant','Public-Open Space')
           AND match_category NOT LIKE '%not mailable%'
        THEN 'Unexpected'
      ELSE 'Review'
    END AS expectation_flag
  FROM summary
)
SELECT
  LandUse,
  COUNT(*) FILTER (WHERE expectation_flag = 'Expected')   AS expected_count,
  COUNT(*) FILTER (WHERE expectation_flag = 'Unexpected') AS unexpected_count,
  COUNT(*) FILTER (WHERE expectation_flag = 'Review')     AS review_count,
  COUNT(*)                                               AS total_count
FROM flagged
GROUP BY LandUse
ORDER BY total_count DESC;
""",pageLength=100);
```


```{python}
#| output: asis
show_result_set("""
WITH summary AS (
  SELECT
    ParcelID,
    LandUse,
    PropertyClass,
    COUNT(DISTINCT AddressId) AS address_count,
    COUNT_IF(AddressMailable = 'Yes') AS mailable_count,
    CASE
      WHEN COUNT(DISTINCT AddressId) = 0 THEN 'No match'
      WHEN COUNT(DISTINCT AddressId) = 1 AND COUNT_IF(AddressMailable = 'Yes') = 1
        THEN 'Single address (mailable)'
      WHEN COUNT(DISTINCT AddressId) = 1 AND COUNT_IF(AddressMailable = 'Yes') = 0
        THEN 'Single address (not mailable)'
      WHEN COUNT(DISTINCT AddressId) > 1 AND COUNT_IF(AddressMailable = 'Yes') = 1
        THEN 'Multiple addresses (1 mailable)'
      WHEN COUNT(DISTINCT AddressId) > 1 AND COUNT_IF(AddressMailable = 'Yes') > 1
        THEN 'Multiple addresses (many mailable)'
      WHEN COUNT(DISTINCT AddressId) > 1 AND COUNT_IF(AddressMailable = 'Yes') = 0
        THEN 'Multiple addresses (none mailable)'
      ELSE 'Unclassified'
    END AS match_category
  FROM parcel_address_join
  GROUP BY ParcelID, LandUse, PropertyClass
),
flagged AS (
  SELECT
    ParcelID,
    LandUse,
    PropertyClass,
    match_category,
    CASE
      WHEN LandUse LIKE 'Single Family%' 
           AND match_category = 'Single address (mailable)'
        THEN 'Expected'
      WHEN LandUse LIKE 'Single Family%' 
           AND match_category <> 'Single address (mailable)'
        THEN 'Unexpected'

      WHEN LandUse IN ('Duplex (2 Family)', 'Multi-Family', 'Mixed-Use')
           AND match_category LIKE 'Multiple addresses%'
        THEN 'Expected'
      WHEN LandUse IN ('Duplex (2 Family)', 'Multi-Family', 'Mixed-Use')
           AND match_category NOT LIKE 'Multiple addresses%'
        THEN 'Unexpected'

      WHEN LandUse IN ('Commercial','Office','Institutional')
           AND match_category IN ('Multiple addresses (many mailable)',
                                  'Single address (mailable)')
        THEN 'Expected'
      WHEN LandUse IN ('Commercial','Office','Institutional')
           AND match_category NOT IN ('Multiple addresses (many mailable)',
                                      'Single address (mailable)')
        THEN 'Unexpected'

      WHEN LandUse IN ('Vacant','Public-Open Space')
           AND match_category LIKE '%not mailable%'
        THEN 'Expected'
      WHEN LandUse IN ('Vacant','Public-Open Space')
           AND match_category NOT LIKE '%not mailable%'
        THEN 'Unexpected'

      ELSE 'Review'
    END AS expectation_flag
  FROM summary
)
SELECT
  LandUse,
  PropertyClass,
  COUNT(*) FILTER (WHERE expectation_flag = 'Expected')   AS expected_count,
  COUNT(*) FILTER (WHERE expectation_flag = 'Unexpected') AS unexpected_count,
  COUNT(*) FILTER (WHERE expectation_flag = 'Review')     AS review_count,
  COUNT(*)                                               AS total_count
FROM flagged
GROUP BY LandUse, PropertyClass
ORDER BY LandUse, total_count DESC, PropertyClass;
""",pageLength=100);
```

## Finally, create interim table

```{python}
x = con.execute("""
-- Step 1: join parcels and addresses
CREATE OR REPLACE TABLE parcel_address_join AS
SELECT
    p.ParcelID,
    p.PIN,
    p.OwnerName,
    p.MailAddress,
    p.MailCity,
    p.MailState,
    p.MailZip,
    p.AssessmentDate,
    p.LandValue,
    p.DwellingValue,
    p.TotalValue,
    p.LandSqFt,
    p.PropertyClassID,
    p.PropertyClass,
    p.LandUse,
    p.OwnerOccupied,
    p.FanUse,
    p.FanUseType,
    p.FanUseOrder,
    p.geometry AS parcel_geometry,

    a.AddressId,
    a.AddressLabel,
    a.BuildingNumber,
    a.StreetDirection,
    a.StreetName,
    a.StreetType,
    a.ExtensionWithUnit,
    a.UnitType,
    a.UnitValue,
    a.ZipCode,
    a.Mailable,
    a.StatePlaneX,
    a.StatePlaneY,
    a.Latitude,
    a.Longitude,
    a.geometry AS address_geometry,

    -- Add helper flags
    (CASE WHEN a.Mailable = 'Yes' THEN 1 ELSE 0 END) AS is_mailable
FROM parcels p
LEFT JOIN addresses a
  ON ST_Within(a.geometry, p.geometry);   -- adjust join rule if you used XY coords
""");
```


```{python}
x = con.execute("""
CREATE OR REPLACE TABLE parcel_address_join_with_flags AS
WITH classified AS (
  SELECT
    ParcelID,
    LandUse,
    PropertyClass,
    COUNT(DISTINCT AddressId) AS address_count,
    SUM(is_mailable) AS mailable_count
  FROM parcel_address_join
  GROUP BY ParcelID, LandUse, PropertyClass
),
flags AS (
  SELECT
    c.*,
    CASE
      WHEN address_count = 0 THEN 'No match'
      WHEN address_count = 1 AND mailable_count = 1 THEN 'Single address (mailable)'
      WHEN address_count = 1 AND mailable_count = 0 THEN 'Single address (not mailable)'
      WHEN address_count > 1 AND mailable_count = 1 THEN 'Multiple addresses (1 mailable)'
      WHEN address_count > 1 AND mailable_count > 1 THEN 'Multiple addresses (many mailable)'
      WHEN address_count > 1 AND mailable_count = 0 THEN 'Multiple addresses (none mailable)'
      ELSE 'Unclassified'
    END AS match_category
  FROM classified c
),
label_counts AS (
  SELECT 
    AddressLabel,
    COUNT(DISTINCT ParcelID) AS label_parcel_count
  FROM parcel_address_join
  GROUP BY AddressLabel
)
SELECT
  j.*,
  f.address_count,
  f.mailable_count,
  f.match_category,
  CASE
    WHEN j.LandUse LIKE 'Single Family%' 
         AND f.match_category = 'Single address (mailable)' THEN 'Expected'
    WHEN j.LandUse LIKE 'Single Family%' 
         AND f.match_category <> 'Single address (mailable)' THEN 'Unexpected'

    WHEN j.LandUse IN ('Duplex (2 Family)','Multi-Family','Mixed-Use')
         AND f.match_category LIKE 'Multiple addresses%' THEN 'Expected'
    WHEN j.LandUse IN ('Duplex (2 Family)','Multi-Family','Mixed-Use')
         AND f.match_category NOT LIKE 'Multiple addresses%' THEN 'Unexpected'

    WHEN j.LandUse IN ('Commercial','Office','Institutional')
         AND f.match_category IN ('Multiple addresses (many mailable)','Single address (mailable)') THEN 'Expected'
    WHEN j.LandUse IN ('Commercial','Office','Institutional')
         AND f.match_category NOT IN ('Multiple addresses (many mailable)','Single address (mailable)') THEN 'Unexpected'

    WHEN j.LandUse IN ('Vacant','Public-Open Space')
         AND f.match_category LIKE '%not mailable%' THEN 'Expected'
    WHEN j.LandUse IN ('Vacant','Public-Open Space')
         AND f.match_category NOT LIKE '%not mailable%' THEN 'Unexpected'

    ELSE 'Review'
  END AS expectation_flag,
  l.label_parcel_count
FROM parcel_address_join j
JOIN flags f USING (ParcelID, LandUse, PropertyClass)
LEFT JOIN label_counts l USING (AddressLabel);
"""
)
```


```{python}
df = con.execute("SELECT * FROM parcel_address_join_with_flags").df()
df.to_parquet("ParcelAddressJoin_in_fan.parquet", engine="pyarrow") 
```
## Data Dictionary

Perfect 👍 — here’s a **full schema documentation** for `parcel_address_join_with_flags`, structured for readability and ready to drop into a README, Quarto doc, or data dictionary.

---

# 📑 Table Schema: `parcel_address_join_with_flags`

**Description**
This table links **Parcels** (tax assessment records) with **Addresses** (city-recognized mailing addresses), enriched with classification fields and quality-control flags.

* **One row for every Parcel ↔ Address combination**.
* Contains all relevant attributes from both source datasets plus derived fields for analysis.
* Stored in Parquet (`ParcelAddressJoin_in_fan.parquet`) for reuse.

---

## 1. Parcel Attributes

(From the *Parcels* dataset)

| Column            | Type     | Description                                                                                    |
| ----------------- | -------- | ---------------------------------------------------------------------------------------------- |
| `ParcelID`        | INTEGER  | Unique parcel identifier in the city GIS.                                                      |
| `PIN`             | VARCHAR  | Parcel Identification Number (tax lot ID).                                                     |
| `CountOfPIN`      | INTEGER  | Number of PINs associated with this parcel (multi-PIN parcels).                                |
| `OwnerName`       | VARCHAR  | Name of the current owner of the parcel.                                                       |
| `MailAddress`     | VARCHAR  | Mailing street address of the owner (may differ from property location).                       |
| `MailCity`        | VARCHAR  | City portion of the owner’s mailing address.                                                   |
| `MailState`       | VARCHAR  | State portion of the owner’s mailing address.                                                  |
| `MailZip`         | VARCHAR  | ZIP code of the owner’s mailing address.                                                       |
| `AssessmentDate`  | VARCHAR  | Date of most recent assessment.                                                                |
| `LandValue`       | DOUBLE   | Assessed land value.                                                                           |
| `DwellingValue`   | DOUBLE   | Assessed building value.                                                                       |
| `TotalValue`      | DOUBLE   | Total assessed value.                                                                          |
| `LandSqFt`        | DOUBLE   | Parcel land area in square feet.                                                               |
| `ProvalAsmtNhood` | VARCHAR  | Assessment neighborhood code.                                                                  |
| `TaxExemptCode`   | VARCHAR  | Tax exemption code (if applicable).                                                            |
| `PropertyClassID` | VARCHAR  | Internal property classification ID.                                                           |
| `PropertyClass`   | VARCHAR  | Human-readable property classification (e.g., *R Two Story*, *B Commercial Common Area Main*). |
| `LandUse`         | VARCHAR  | Land use category (e.g., *Single Family*, *Multi-Family*, *Commercial*, *Vacant*).             |
| `OwnerOccupied`   | BIGINT   | Flag (1/0) if the property is owner-occupied.                                                  |
| `FanUse`          | VARCHAR  | Local neighborhood-specific use classification.                                                |
| `FanUseType`      | VARCHAR  | Derived Fan District use type (e.g., *FanOwner*, *FanRenter*).                                 |
| `FanUseOrder`     | BIGINT   | Ordering value for FanUse categories.                                                          |
| `parcel_geometry` | GEOMETRY | Polygon geometry of the parcel boundary.                                                       |

---

## 2. Address Attributes

(From the *Addresses* dataset)

| Column              | Type     | Description                                                                 |
| ------------------- | -------- | --------------------------------------------------------------------------- |
| `AddressId`         | VARCHAR  | Unique address record identifier.                                           |
| `AddressLabel`      | VARCHAR  | Formatted mailing address (human-readable, e.g. *401 N Robinson St Apt A*). |
| `BuildingNumber`    | VARCHAR  | Street/building number.                                                     |
| `StreetDirection`   | VARCHAR  | Street direction (e.g., N, S, E, W).                                        |
| `StreetName`        | VARCHAR  | Street name.                                                                |
| `StreetType`        | VARCHAR  | Street type (e.g., St, Ave, Blvd).                                          |
| `ExtensionWithUnit` | VARCHAR  | Address extension (e.g., *Rear*, *Suite*, *Apt*).                           |
| `UnitType`          | VARCHAR  | Unit type (e.g., *Apt*, *Unit*, *Suite*).                                   |
| `UnitValue`         | VARCHAR  | Unit number or identifier.                                                  |
| `ZipCode`           | VARCHAR  | Postal ZIP code.                                                            |
| `Mailable`          | VARCHAR  | “Yes” if USPS deliverable, “No” otherwise.                                  |
| `StatePlaneX`       | DOUBLE   | X coordinate (State Plane projection).                                      |
| `StatePlaneY`       | DOUBLE   | Y coordinate (State Plane projection).                                      |
| `Latitude`          | DOUBLE   | Latitude coordinate (WGS84).                                                |
| `Longitude`         | DOUBLE   | Longitude coordinate (WGS84).                                               |
| `address_geometry`  | GEOMETRY | Point geometry of the address location.                                     |

---

## 3. Derived Fields (Flags and Counts)

| Column               | Type    | Description                                                                                                                                                                                                                                                                                                         |
| -------------------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `is_mailable`        | INTEGER | 1 if `Mailable = 'Yes'`, else 0.                                                                                                                                                                                                                                                                                    |
| `address_count`      | INTEGER | Number of addresses linked to the parcel.                                                                                                                                                                                                                                                                           |
| `mailable_count`     | INTEGER | Number of mailable addresses linked to the parcel.                                                                                                                                                                                                                                                                  |
| `match_category`     | VARCHAR | Classification of parcel–address relationship. Possible values: <br> - `No match` <br> - `Single address (mailable)` <br> - `Single address (not mailable)` <br> - `Multiple addresses (1 mailable)` <br> - `Multiple addresses (many mailable)` <br> - `Multiple addresses (none mailable)` <br> - `Unclassified`. |
| `expectation_flag`   | VARCHAR | Quality flag comparing `match_category` against `LandUse` expectations. Possible values: <br> - `Expected` <br> - `Unexpected` <br> - `Review`.                                                                                                                                                                     |
| `label_parcel_count` | INTEGER | Number of distinct parcels sharing the same `AddressLabel`.                                                                                                                                                                                                                                                         |

---

## 4. Row Semantics

* Each row = **one parcel–address combination**.
* Parcels with multiple addresses → appear multiple times.
* Addresses tied to multiple parcels (rare, e.g., condos, common-area splits) → appear multiple times.
* Together, this table enables analysis at the **parcel-level**, **address-level**, or **household-level**.

---

✅ With this schema, you can:

* Join members (by `AddressLabel` or `AddressId`) and check anomalies (`expectation_flag`).
* Collapse to households (using `AddressLabel`, `label_parcel_count`).
* Do penetration analysis across `LandUse` / `PropertyClass`.

---

👉 Do you want me to also sketch a **schema diagram** (like an ERD-style box with key columns and relationships between parcels, addresses, and the join) so you have a visual to drop into documentation?


## How many rows share the same AddressLabel?

```{python}
x = con.execute("""
create or replace table parcel_address_join_with_flags as
SELECT * FROM 'ParcelAddressJoin_in_fan.parquet';
""")
```

```{python}
#| output: asis
show_result_set("""
SELECT
    AddressLabel,
    COUNT(DISTINCT ParcelID) AS parcel_count,
    COUNT(DISTINCT AddressId) AS addressid_count,
    COUNT(*) AS join_rows
FROM parcel_address_join_with_flags
GROUP BY AddressLabel
HAVING COUNT(DISTINCT ParcelID) > 1
ORDER BY parcel_count DESC;

""",pageLength=100);
```

# Working with Contacts


```{python}
fda_contacts_filename = get_newest_file( precious_folder,'FDA_contacts',ext='.csv')

contacts = pd.read_csv(fda_contacts_filename)

# Dictionary of replacements
street_replacements = {
    "AVENUE": "AVE",
    "ALLEY" : "AL",
    "PLACE": "PL",
    "STREET": "ST",
    "ROAD": "RD",
    "BOULEVARD": "BLVD",
    "COURT": "CT",
    "DRIVE": "DR",
    "LN" : "LANE",
    "CIRCLE" : "CIR",
    "APARTMENT" : "APT"

}

def normalize_address(addr, addr2=""):
    if pd.isna(addr) or str(addr).strip() == "":
        return ""
    addr = addr.upper().strip()
    addr = addr.replace(".#", " ")
    addr = addr.replace(" #6C", " UNIT 6C")

    addr = addr.replace(".", "")
    addr = addr.replace(",", "")
    addr = addr.replace("#", "")
    addr = addr.replace("’", " ")

    addr = addr.replace("1509HANOVER","1509 HANOVER")
    addr = addr.replace("1529’W","1529 W")
    addr = addr.replace("DAVISAVE","DAVIS AVE")
    if addr.endswith("MEADOW"):
        addr = addr.replace("MEADOW","MEADOW AVE")

    # Detect "101A" pattern (building number with unit letter)
    m = re.match(r"^(\d+)\s*([A-D])\s+(.*)", addr)
    if m:
        number, unit, rest = m.groups()
        addr = f"{number} {rest} APT {unit}"

    # Inline unit numbers
    addr = re.sub(r"\s+#(\w+)$", r" APT \1", addr)
    addr = addr.replace(",","")

    # Replace street types at word boundaries
    for long, short in street_replacements.items():
        addr = re.sub(rf"\b{long}\b", short, addr)

    # List of street types you don't want to accidentally collapse
    protected_types = ["AVE", "ST", "PL", "RD", "BLVD", "CT", "DR", "LN", "TER"]

    # Build regex that says "only abbreviate if WEST is not followed by a street type"
    protected_regex = "|".join(protected_types)

    addr = re.sub(rf"^(\d+)\s+NORTH(?!\s+({protected_regex})\b)", r"\1 N", addr)
    addr = re.sub(rf"^(\d+)\s+SOUTH(?!\s+({protected_regex})\b)", r"\1 S", addr)
    addr = re.sub(rf"^(\d+)\s+EAST(?!\s+({protected_regex})\b)",  r"\1 E", addr)
    addr = re.sub(rf"^(\d+)\s+WEST(?!\s+({protected_regex})\b)",  r"\1 W", addr)

    
    # Add Address Line 2 if present
    if pd.notna(addr2) and str(addr2).strip() != "":
        addr2_norm = addr2.upper().strip().replace(".", "")
        addr2_norm = addr2_norm.replace("#", "").strip()  # remove #
        addr2_norm = addr2_norm.replace("-", "").strip()  # remove #
        addr2_norm = re.sub(r"\bAPARTMENT\b", "APT", addr2_norm)  # normalize APARTMENT → APT
        # If it's just a single word (no spaces), prepend "UNIT " unless it already has APT/UNIT
        if " " not in addr2_norm and not addr2_norm.startswith(("UNIT", "APT")):
            addr2_norm = f"UNIT {addr2_norm}"

        for long, short in street_replacements.items():
            addr2_nrom = re.sub(rf"\b{long}\b", short, addr2_norm)
            
        addr2_norm = addr2_norm.replace("KAVACLUB","")
        addr2_norm = addr2_norm.replace("RICHMOND, VA","")
        addr2_norm = addr2_norm.replace("WARSAW CONDOS","")
        addr2_norm = addr2_norm.replace("U10B","UNIT 10B")
        addr2_norm = addr2_norm.replace("U-PL-F","PL-F")
        addr = addr + " " + addr2_norm

    # Special cases
    if addr.endswith(" DUBOIS"):
        addr = addr + " AVE"

    # Collapse multiple spaces
    addr = re.sub(r"\s+", " ", addr).strip()

    return addr


# Apply
contacts["AddressLabel_norm"] = contacts.apply(
    lambda row: normalize_address(row["Address"], row.get("Address Line 2", "")),
    axis=1
)

# Normalize Zip
contacts["Zip_norm"] = contacts["Zip"].astype(str).str.strip().str.upper()

contacts.to_parquet("fda_contacts_normalized.parquet", index=False)

```

```{python}
#| output: asis
show_result_set("""
CREATE OR REPLACE TABLE fda_contacts_normalized AS
SELECT * FROM 'fda_contacts_normalized.parquet';
""",pageLength=100);
```

```{python}
#| output: asis
show_result_set("""
CREATE OR REPLACE TABLE fda_contacts_matched AS
SELECT
    c.*,
    j.ParcelID         AS MatchedParcelID,
    j.LandUse          AS MatchedLandUse,
    j.PropertyClass    AS MatchedPropertyClass,
    j.match_category   AS MatchCategory,
    j.expectation_flag AS ExpectationFlag,
    j.label_parcel_count AS LabelParcelCount,
    CASE 
        WHEN c.Address IS NULL OR trim(c.Address) = '' 
            THEN 'Blank Address'
        WHEN c.Zip_norm NOT IN ('23220','23284')
            THEN 'Zip not in Fan'
        WHEN j.ParcelID IS NOT NULL 
            THEN 'Matched'
        ELSE 'Unmatched'
    END AS MatchStatus
FROM fda_contacts_normalized c
LEFT JOIN parcel_address_join_with_flags j
  ON c.AddressLabel_norm <> ''
 AND j.AddressLabel IS NOT NULL AND j.AddressLabel <> ''
 AND c.AddressLabel_norm = upper(j.AddressLabel)
 AND c.Zip_norm = j.ZipCode;
""",pageLength=100);
```



```{python}
#| output: asis
show_result_set("""
SELECT MatchStatus, COUNT(*) 
FROM fda_contacts_matched
GROUP BY MatchStatus;
""",pageLength=100);
```


## UnMatched contacts


```{python}
#| output: asis
show_result_set("""
SELECT 
    Id,
    DisplayName,
    Address,
    "Address Line 2",
    Zip,
    AddressLabel_norm,
    Zip_norm
FROM fda_contacts_matched
WHERE MatchStatus = 'Unmatched'
ORDER BY AddressLabel_norm
""",pageLength=10);
```

```{python}
#| output: asis
show_result_set("""
describe fda_contacts
""",pageLength=100);
```

```{python}
#| output: asis
show_result_set("""
""",pageLength=100);
```

