---
title: Parcels and Addresses Join
---

```{python}
import os
import re
import sys
import sqlite3
import requests
import numpy as np

import pandas as pd
pd.set_option("display.max_rows", None)

import geopandas as gpd
import matplotlib.pyplot as plt

from matplotlib.patches import Patch
from matplotlib.lines import Line2D
from math import floor

from loguru import logger
# Configure loguru to only log to stderr (console)
logger.remove()  # remove default handler
logger.add(sys.__stderr__, level="INFO", format="{level: <8} | {name}:{function}:{line} - {message}" )  # use the original stderr, not Jupyter’s proxy

## Set up itables
import itables
from itables import show

# Sensible global defaults for itables
itables.options.maxBytes = 0                        # show full content in each cell
itables.options.classes = ["display", "compact"]    # compact, clean look
itables.options.lengthMenu = [10, 25, 50, 100]      # page length menu
itables.options.pageLength = 25
itables.options.buttons = ["copy", "csv", "print"]
itables.options.scrollX = True                      # allow horizontal scroll if needed
itables.options.scrollY = True                      # allow horizontal scroll if needed
itables.options.ordering = True

## Set up duckdb

import duckdb
con = duckdb.connect()
x = con.execute("INSTALL spatial; LOAD spatial;")
```

```{python}
def show_result_set( query, **kwargs ):
    # This depends on global variable CON to keep the argument list clean
    print('::: {.column-page-right style="font-size:0.7em"}')
    df = con.execute( query ).fetch_df()
    show(df,**kwargs)
    print(':::')
```


# Create merge file

```{python}
x = con.execute("""
CREATE OR REPLACE TABLE addresses AS SELECT * FROM 'Addresses_in_fan.parquet';
CREATE OR REPLACE TABLE parcels AS SELECT * FROM 'Single_parcels_in_fan.parquet';
CREATE OR REPLACE TABLE contacts AS SELECT * FROM 'Contacts_in_fda.parquet';
""");
```

```{python}
show_result_set("""
describe contacts
""");
```

## Remove bundle members, keeping bundle admins and single-person households.

```{python}
x = con.execute("""
-- 1️⃣ Add new columns if they don’t exist
ALTER TABLE contacts ADD COLUMN IF NOT EXISTS member_names TEXT;
ALTER TABLE contacts ADD COLUMN IF NOT EXISTS member_cnt INT DEFAULT 1;
""")
```

```{python}
x = con.execute("""
-- 2️⃣ Compute the bundle summaries (members + admin) and update bundle administrators
UPDATE contacts AS admin
SET
    member_names = summary.member_names,
    member_cnt = summary.member_cnt
FROM (
    SELECT 
        bundleid,
        STRING_AGG(firstname || ' ' || lastname, ', ') AS member_names,
        COUNT(*) AS member_cnt
    FROM contacts
    WHERE memberrole IN ('Bundle Administrator', 'Bundle member')
    GROUP BY bundleid
) AS summary
WHERE admin.bundleid = summary.bundleid
  AND admin.memberrole = 'Bundle Administrator';

-- 3️⃣ Ensure individuals with no bundleid have member_cnt = 1
UPDATE contacts
SET member_cnt = 1
WHERE bundleid IS NULL;

-- 4️⃣ Delete bundle member rows (keep admins and non-bundled)
DELETE FROM contacts
WHERE memberrole = 'Bundle member'
  AND bundleid IS NOT NULL;

update contacts
  set member_names= firstname || ' ' || lastname
  where member_names is NULL;

""")
```

## Full outer join

Combine single parcels and addresses.

```{python}
#| output: asis

x = con.execute("""
CREATE OR REPLACE TABLE parcel_address_join AS
SELECT 
    p.RepresentativeParcelID,
    p.LandUse,
    p.PropertyClass,
    p.geometry AS parcel_geom,
    p.ParcelGeometryID,
    p.FanUse,
    p.FanUseType,
    p.FanUseOrder,
    a.AddressId,
    a.AddressLabel,
    a.BuildingNumber,
    a.StreetDirection,
    a.StreetName,
    a.StreetType,
    a.ExtensionWithUnit,
    a.UnitType,
    a.UnitValue,
    A.ZipCode,
    a.Mailable AS AddressMailable,
    a.AddressBase,
    a.AddressExtension,
    a.AddressStreet,
    a.geometry AS addr_geom,
    a.AddressGeometryID
FROM parcels p
  FULL OUTER JOIN addresses a
  ON ST_Within(a.geometry, p.geometry);
""")
```

## Examine Parcels

Looking at single parcels, how to addresses line up?  

```{python}
#| output: asis
show_result_set("""
WITH classified AS (
  SELECT 
    RepresentativeParcelID,
    COUNT(DISTINCT AddressId) AS address_count,
    COUNT_IF(AddressMailable = 'Yes') AS mailable_count
  FROM parcel_address_join
  GROUP BY RepresentativeParcelID
)
SELECT
  CASE
    WHEN address_count = 0 THEN 'No match'
    WHEN address_count = 1 AND mailable_count = 1 THEN 'Single address (mailable)'
    WHEN address_count = 1 AND mailable_count = 0 THEN 'Single address (not mailable)'
    WHEN address_count > 1 AND mailable_count = 1 THEN 'Multiple addresses (1 mailable)'
    WHEN address_count > 1 AND mailable_count > 1 THEN 'Multiple addresses (many mailable)'
    WHEN address_count > 1 AND mailable_count = 0 THEN 'Multiple addresses (none mailable)'
    ELSE 'Unclassified'
  END AS match_category,
  COUNT(*) AS parcel_count
FROM classified
GROUP BY match_category
ORDER BY parcel_count DESC;

""",pageLength=10)
```

## Examine Addresses

How many parcels are associated with each address?  We expect each address to be matched
with only one parcel - because we merge multiple parcels sharing the same geometry into single parcels.

We may see a few addresses without parcels.  Why?

```{python}
#| output: asis
show_result_set("""
WITH address_classified AS (
  SELECT 
    AddressId,
    AddressMailable,
    COUNT(DISTINCT RepresentativeParcelID) AS parcel_count
  FROM parcel_address_join
  GROUP BY AddressId,AddressMailable
)
SELECT
  CASE
    WHEN parcel_count = 0 THEN 'No parcel match'
    WHEN parcel_count = 1 THEN 'Single parcel'
    WHEN parcel_count > 1 THEN 'Multiple parcels'
  END AS parcel_category,
  COUNT(*) AS address_count,
  AddressMailable
FROM address_classified
GROUP BY AddressMailable,parcel_category
ORDER BY address_count DESC;
""",pageLength=10
)
```

## Merge in contacts.

```{python}
x = con.execute("""
create or replace table golden_join as
select
  a.*,
  b.*
from
  parcel_address_join a
  full outer join contacts b on (a.addressLabel=b.addresslabel);
update golden_join
  set AddressNote='Valid Fan Address'
  where Member is NULL;
""")
```

## Assign Zones

```{python}
x = con.execute("""
-- 1️⃣ Add the new column
ALTER TABLE golden_join ADD COLUMN zone TEXT DEFAULT NULL;
""")
```

```{python}
x = con.execute("""
-- 2️⃣ Populate the new column based on AddressStreet
UPDATE golden_join
SET zone = CASE
    WHEN AddressStreet ILIKE '%FLOYD%' then 'Floyd Zone'
    when AddressStreet ILIKE '%W MAIN%'
       OR AddressStreet in ('S Cathedral Pl','Cathedral Pl')
       or AddressStreet in ('S Addison St','S Allen Ave','S Brunswick St','S Granby St',
        'S Harvie St','S Lombardy St','S Meadow St','S Morris St','S Mulberry St',
        'S Plum St','S Robinson St','S Rowland St','S Shields Ave',
        'S Stafford Ave','S Vine St','Sidewalk Al') THEN 'W Main Zone'
    WHEN AddressStreet ILIKE '%GROVE%' 
      or AddressStreet ILIKE '%HORSE BARN%' THEN 'Grove Zone'
    WHEN AddressStreet ILIKE '%HANOVER%' 
      or AddressStreet ILIKE '%HARVIE PL%'
      or AddressStreet ILIKE '%MADUMBIE LANE%'
      OR AddressStreet ILIKE '%TROUVAILLE%' THEN 'Hanover Zone'
    WHEN AddressStreet ILIKE '%KENSINGTON%' THEN 'Kensington Zone'
    WHEN AddressStreet ILIKE '%MONUMENT%' 
      OR AddressStreet ILIKE '%STUART CIR%'
      OR AddressStreet ILIKE '%W FRANKLIN%' THEN 'Monument / W Franklin Zone'
    WHEN AddressStreet ILIKE '%PARK%' THEN 'Park Zone'
    WHEN AddressStreet ILIKE '%STUART AVE%' THEN 'Stuart Zone'
    WHEN AddressStreet ILIKE '%WEST AVE%' 
      or AddressStreet ILIKE '%BOYD%' THEN 'West Ave Zone'
    WHEN AddressStreet ILIKE '%W GRACE%' 
      or addressStreet ILIKE '%SHAFER%' THEN 'W Grace Zone'
    WHEN AddressStreet ILIKE '%W BROAD%' then 'W Broad Zone'
    WHEN REPLACE(AddressStreet, '\u00A0', ' ') ILIKE 'N %' or
      AddressStreet in ('Allison St','Boyd St','Ryland St','Randolph St','Strawberry St') THEN CASE
      when try_cast(split_part(BuildingNumber,' ',1) as integer) < 100 then 'Floyd Zone'
      when try_cast(split_part(BuildingNumber,' ',1) as integer) < 200 then 'Grove Zone'
      when try_cast(split_part(BuildingNumber,' ',1) as integer) < 300 then 'Hanover Zone'
      when try_cast(split_part(BuildingNumber,' ',1) as integer) < 400 then 'Stuart Zone'
      when try_cast(split_part(BuildingNumber,' ',1) as integer) < 500 then 'Floyd Zone'
      when try_cast(split_part(BuildingNumber,' ',1) as integer) < 600 then 'Park Zone'
      when try_cast(split_part(BuildingNumber,' ',1) as integer) < 700 then 'Monument / W Franklin Zone'
      when try_cast(split_part(BuildingNumber,' ',1) as integer) < 900 then 'W Grace Zone'
      when try_cast(split_part(BuildingNumber,' ',1) as integer) >= 900 then 'W Broad Zone'
      else 'uncaught value' end
    else 'zNo Address'
END;


""")
```

```{python}
show_result_set("""
select zone,
  sum( case when member='True' then 1 else 0 end ) as Member,
  sum( case when Member='False' then 1 else 0 end) as Contact,
  sum( case when member is NULL then 1 else 0 end ) as Null_member
  from golden_join 
  group by zone order by zone
""")
```



```{python}
show_result_set("""
select 
  FanUse, LandUse,
  sum( 1 ) as Total,
  sum( case when Member='True' then 1 else 0 end ) as member_cnt,
  sum( case when Member<>'True' and Member is not NULL then 1 else 0 end) as contacts_cnt,
  sum( case when Member is NULL then 1 else 0 end ) as not_in_fda
from
  golden_join
group by
  FanUse, LandUse,FanUseOrder
order by
  FanUseOrder, LandUse
""")
```



```{python}
show_result_set("""
select 
  FanUse,
  sum( 1 ) as Total
from
  golden_join
group by
  FanUse
""")
```


```{python}
show_result_set("""
describe golden_join
""")
```


```{python}
x = con.execute("""
create or replace view golden_view as
select
  email,
  lastName || ', ' || firstname as SortableName,
  firstname || ' ' || lastname as FullName,
  firstname,
  lastname,
  AddressLabel,
  City,
  State,
  Zip_norm,
  BuildingNumber,
  AddressStreet,
  AddressBase,
  member,
  membershiplevelName,
  member_cnt,
  member_names,
  FanUse,
  FanUseOrder,
  FanUseType,
  LandUse,
  PropertyClass,
  AddressMailable,
  AddressNote,
  zone,
  case
    when member='True' then 'Current member'
    when member='False' and len(membershiplevelname)>0 then 'Expired member'
    when member='False' and (len(membershiplevelname)=0 or membershiplevelname is NULL) then 'Contact'
    else 'Not in FDA DB' end as FanMemberStatus,
  (case when Member='True' then 1 else 0 end ) as Stats_Member_cnt,
  (case when Member<>'True' and Member is not NULL then 1 else 0 end) as Stats_Contacts_cnt,
  (case when Member is NULL and LandUse is not NULL then 1 else 0 end ) as Stats_Addr_not_in_FDA,
  (case when Member is NULL and LandUse is NULL then 1 else 0 end ) as Stats_Addr_not_in_Fan,
  id as UserId,
  RepresentativeParcelId,
  ParcelGeometryID,
  AddressId,
  AddressGeometryId
from
  golden_join
order by
  UserName
""")
```

```{python}
show_result_set("""
select * from golden_view order by Member, SortableName, AddressLabel
""",pageLength=10)
```

```{python}
df = con.execute("""
select * from golden_view
order by 
case when Member='True' then 1
  when Member='False' then 10
  else 99 end,
Member,
case when not (membershiplevelname is NULL or membershiplevelname='') then 1 else 10 end,
AddressStreet,
AddressLabel,
SortableName
""").fetch_df()

with pd.ExcelWriter("fda_merged.xlsx", engine="xlsxwriter") as writer:
    df.to_excel(writer, sheet_name="Full join", index=False)
    # Example: auto-adjust column width
    for column in df:
        col_width = max(df[column].astype(str).map(len).max(), len(column))
        col_idx = df.columns.get_loc(column)
        writer.sheets["Full join"].set_column(col_idx, col_idx, col_width)

    
df.to_parquet("Golden_fan.parquet")

```
